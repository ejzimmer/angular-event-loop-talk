<template id="task-source">
  <style>
      :host {
        display: flex;
        --diameter: 9vh;
        cursor: pointer;
      }
      .container {
        width: 100%;
      }
      .thread {
        --diameter: calc(4.5vh - 8px);
        display: flex;
        flex-wrap: wrap;
      }

      .timer {
				--colour: white;
				border: 4px solid var(--colour);
				border-radius: 50%;
				width: var(--diameter);
				height: var(--diameter);
				position: relative;
				flex-shrink: 0;
        transition: transform steps(12, end);
			}
			.timer::after {
				content: '';
				border: 2px solid var(--colour);
				height: calc(var(--diameter) / 2 - 4px);
				position: absolute;
				left: 50%;
      }
      .timer.go {
        transform: rotate(1turn);
      }

      .html {
        display: flex;
      }
      .html::after {
        content: '<html>\A...</html>';
        font-family: 'Courier New', Courier, monospace;
        font-weight: bold;
        font-size: 2vw;
        margin: auto;
      }

      .network {
        width: var(--diameter);
        height: var(--diameter);
        margin: auto;
        background: repeating-radial-gradient(circle at bottom left, white, white 9%, transparent 9%, transparent 18%);
        border-top-right-radius: 100%;
        transform-origin: bottom left;
        transform:  translateX(50%) rotate(-.125turn);
        position: relative;
      }
      .network::after {
        content: '';
        display: block;
        width: 18%;
        height: 18%;
        border-radius: 50%;
        background-color: white;
        position: absolute;
        left: -4.5%;
        bottom: -4.5%;
      }

      .drive {
        width: var(--diameter);
        height: calc(var(--diameter) * 1.4);
        border: 2px solid white;
        border-radius: 4px;
        position: relative;
        background: 
          radial-gradient(circle at 50% 40%, transparent, transparent 5%, white 5%, white 10%, darkgrey 10%, grey 50%, white 50%, white calc(50% + 1px), transparent 20%),
          radial-gradient(circle at 30% 75%, grey 20%, white calc(20% + 4px), transparent calc(20% + 4px));
      }
      .drive .arm {
        border: 8px solid transparent;
        border-bottom-color: white;
        box-sizing: border-box;
        width: 8px;
        position: absolute;
        bottom: 20%;
        left: calc(30% - 8px);
        transform-origin: bottom;
        transform: rotate(.1turn);
      }
  </style>
  <div class="container"></div>
</template>
<script>
  const taskSourceDocument = document.currentScript.ownerDocument;
  class TaskSource extends HTMLElement {
    constructor() {
      super();

      this.shadow = this.attachShadow({ mode: 'closed' });
      const content = taskSourceDocument.getElementById('task-source').content.cloneNode(true);
      this.shadow.appendChild(content);

      this.type = this.attributes.type.value;
      this.container = this.shadow.querySelector('.container');

      if (this.type === 'browser') {
        const browser = document.createElement('browser-window');
        this.container.appendChild(browser);
      } else {
        this.source = document.createElement('div');
        this.source.classList.add(this.type);
        this.container.appendChild(this.source);

        this.thread = document.createElement('div');
        this.thread.classList.add('thread');
        this.container.appendChild(this.thread);

        if (this.type === 'drive') {
          this.arm = document.createElement('div');
          this.arm.classList.add('arm');
          this.source.appendChild(this.arm);
        }
      }
    }

    connectedCallback() {
      if (this.type === 'drive') {
        const driveHeight = this.source.getBoundingClientRect().height;
        const armHeight = driveHeight * 0.35;
        this.arm.style.height = armHeight;
        this.arm.style.borderBottomWidth = `${armHeight}px`;
      }

      if (this.type === 'html') {
        this.container.addEventListener('click', () => {
          this.addTask();
        });
      }
      if (this.source && this.type !== 'html') {
        this.source.addEventListener('click', () => {
          this.startAsyncTask();
        });
      }
    }

    startAsyncTask() {
      const asyncTask = document.createElement('div');
      
      asyncTask.classList.add(this.type);
      asyncTask.style.transitionDuration = this.getDuration();

      this.thread.appendChild(asyncTask);

      requestAnimationFrame(() => asyncTask.classList.add('go'));

      asyncTask.addEventListener('transitionend', () => {
        this.addTask();
        asyncTask.remove();
      })
    }

    getDuration() {
      return `${Math.random() * 10}s`;
    }

    addTask() {
      document.body.dispatchEvent(new CustomEvent('task', { detail: this.type }));     
    }
  }
  customElements.define('task-source', TaskSource);
</script>

