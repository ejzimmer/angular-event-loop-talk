<template id="selector">
  <style>
    :host {
      display: flex;
      position: fixed;
      transition: left .3s;
    }
    .loop {
      margin: auto;
      width: 100%;
      height: 100%;
    }
    .loop.spin {
      transition: transform 1s .3s;
      transform: rotate(-1turn);
    }
    
  </style>
  <img class="loop" src="css/circular-arrow.svg" />
</template>
<script>
  const selectorDocument = document.currentScript.ownerDocument;
  class QueueSelector extends HTMLElement {
    constructor() {
      super();

      this.shadow = this.attachShadow({ mode: 'closed' });
      const content = selectorDocument.getElementById('selector').content.cloneNode(true);
      this.shadow.appendChild(content);

      // setTimeout(() => this.pickQueue(), 1000);
    }

    connectedCallback() {
      const diameter = this.previousElementSibling.clientWidth * 0.5;
      this.style.width = `${diameter}px`;
      this.style.height = `${diameter}px`;

      const firstQueueRect = document.querySelector('task-queue').getBoundingClientRect();
      const left = firstQueueRect.left;
      const bottom = firstQueueRect.bottom;

      this.style.left = `${left}px`;
      this.style.top = `${bottom}px`;

      setInterval(() => this.readyToPaint = true, 10000);
    }

    async pickQueue() {
      const queue = this.getNextQueue();
      if (queue) {
        this.moveToQueue(queue);
        this.spin();
        await queue.runTask();
        this.pickQueue();
      } else {
        await this.wait();
        this.pickQueue();
      }
    }

    getNextQueue() {
      if (this.readyToPaint && this.repaint) {
        this.readyToPaint = false;
        this.repaint = false;
        return this.parentNode.querySelector('rendering-pipeline');
      } else {
        const taskQueue = document.querySelector('task-queue');
        if (taskQueue.getTask(0)) {
          return taskQueue;
        }
      }

      if (this.pipeline === 1) {
        return this.parentNode.querySelector('rendering-pipeline');
      } else if (this.pipeline === 2) {
        console.log('task');
        return document.querySelector('task-queue');
      } 
    }

    moveToQueue(queue) {
      const queueRect = queue.getBoundingClientRect();
      const loopRect = this.getBoundingClientRect();

      const margin = (queueRect.width - loopRect.width) / 2;

      const left = queueRect.left + margin;
      this.style.left = `${left - 40}px`; // I think reveal makes things off by 40px for some reason
    }

    spin() {
      this.loop.addEventListener('transitionend', (event) => {
        if (event.propertyName === 'transform') {
          this.loop.classList.remove('spin');
        }
      });
      this.loop.classList.add('spin');
    }

    wait() {
      return new Promise(resolve => setTimeout(resolve, 3000));
    }
  }
  customElements.define('queue-selector', QueueSelector);
</script>