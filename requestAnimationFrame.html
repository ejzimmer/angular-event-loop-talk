<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Event Loop with Animation Frames</title>
    <script>
        // function doAsyncThing() {
        //   console.log('doing async thing');
        //   return Promise.resolve();
        // }
        // setTimeout(() => {
        //   console.log('Running first timeout');
        //   doAsyncThing().then(() => {
        //     console.log('doing first then');
        //   })
        //   requestAnimationFrame(() => {
        //     console.log('Running animation frame');
        //     setTimeout(() => {
        //       console.log('new task from animation callback')
        //     })
        //     doAsyncThing().then(() => {
        //       console.log('new microtask from animation callback');
        //     })
        //   })
        // });
        // setTimeout(() => {
        //   console.log('Running second timeout');
        // });
        // let promise = Promise.resolve();
        // while (true) {
        //   console.log('resolving');
        //   promise = promise.then(() => Promise.resolve());
        // }
        let count = 0;
        let time = new Date();
        const times = [];
        setTimeout(requestAnimationFrame(showTime), 5000);
        function showTime() {
          const nextTime = new Date();
          times.push(nextTime - time);
          time = nextTime;
          if (count++ < 100) {
            requestAnimationFrame(showTime);
          }
        }
        console.log(times);
        // totally make a graph of this

        // also - mention infinite loop of timeouts or request animation frame is ok
        // infinite loop of promise is death
      
      </script>
          
    
    <link rel="stylesheet" href="css/demo.css">

    <link rel="import" href="components/event-loop.html">
		<link rel="import" href="components/browser.html">
		<link rel="import" href="components/queues.html">
		<link rel="import" href="components/rendering-pipeline.html">
		<link rel="import" href="components/queue-selector.html">
		<link rel="import" href="components/queue.html">
		<link rel="import" href="components/task-source.html">
	</head>
	<body>
		<section>
      <event-loop>
        <div class="sources">
          <task-source type="html"></task-source>
          <task-source type="browser"></task-source>
          <task-source type="timer"></task-source>
          <task-source type="network"></task-source>
          <task-source type="drive"></task-source>
          <task-source type="promise"></task-source>
          <task-source type="animation"></task-source>
        </div>
        <task-queues>
          <task-queue type="browser"></task-queue>
          <task-queue></task-queue>  
          <task-queue type="microtask"></task-queue>
          <task-queue type="animation"></task-queue>
        </task-queues>
      </event-loop>
    </section>
    
    <div class="notes">
      If you have a promise resolve in a requestAnimationFrame, does it run after
      requestAnimationFrame, after repaint, or after next task?
    </div>
	
		<div class="notes">				
      Can have lots of other queues - Node has separate queues for timeouts and I/O callbacks
      Browsers might have separate queues for user-generated callbacks and DOM parsing callbacks
    </div>
	</body>
</html>
